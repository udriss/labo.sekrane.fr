
// lib/calendar-utils-timeslots.ts
// Nouvelles fonctions utilisant le syst√®me TimeSlots avec gestion d'√©tat centralis√©e

import pool from '@/lib/db'
import { TimeSlot, CalendarEvent, EventState } from '@/types/calendar'
import { generateTimeSlotId, getActiveTimeSlots } from '@/lib/calendar-utils-client'
import { v4 as uuidv4 } from 'uuid'
import { format } from 'date-fns'
import { 
  createTimeslot, 
  proposeNewTimeslots, 
  getTimeslotsByEventId
} from '@/lib/timeslots-database'
import { TimeslotProposal, Discipline } from '@/types/timeslots'

// Types pour les salles en tant qu'objets JSON
export interface RoomData {
  id: string
  name: string
  capacity?: number
  description?: string
}

// Fonction pour normaliser les donn√©es de salle (string ou objet)
export function normalizeRoomData(room: string | RoomData | null | undefined): RoomData | null {
  if (!room) return null
  
  if (typeof room === 'string') {
    // Si c'est une cha√Æne, essayer de parser comme JSON
    if (room.trim().startsWith('{')) {
      try {
        const parsed = JSON.parse(room)
        return {
          id: parsed.id || parsed.name || room,
          name: parsed.name || room,
          capacity: parsed.capacity,
          description: parsed.description
        }
      } catch {
        // Si le parsing √©choue, traiter comme nom simple
        return {
          id: room,
          name: room
        }
      }
    } else {
      // Nom simple de salle
      return {
        id: room,
        name: room
      }
    }
  }
  
  // Si c'est d√©j√† un objet
  return {
    id: room.id || room.name || 'unknown',
    name: room.name || room.id || 'Salle inconnue',
    capacity: room.capacity,
    description: room.description
  }
}

// Fonction pour obtenir le nom d'affichage d'une salle
export function getRoomDisplayName(room: string | RoomData | null | undefined): string {
  if (!room) return ''
  
  if (typeof room === 'string') {
    return room
  }
  
  return room.name || room.id || 'Salle inconnue'
}

// Fonction pour comparer deux room data
export function compareRoomData(room1: string | RoomData | null | undefined, room2: string | RoomData | null | undefined): boolean {
  if (!room1 && !room2) return true
  if (!room1 || !room2) return false
  
  const normalized1 = normalizeRoomData(room1)
  const normalized2 = normalizeRoomData(room2)
  
  if (!normalized1 || !normalized2) return false
  
  return normalized1.id === normalized2.id
}

// Fonction pour convertir un objet room en JSON string pour la base de donn√©es
export function serializeRoomData(room: RoomData | null): string | null {
  if (!room) return null
  return JSON.stringify(room)
}

// Fonction s√©curis√©e pour s√©rialiser n'importe quel objet JSON pour MySQL
export function safeJsonStringify(value: any): string | null {
  if (value === null || value === undefined) {
    return null
  }
  
  if (typeof value === 'string' && value.trim() === '') {
    return null
  }
  
  try {
    const result = JSON.stringify(value)
    // √âviter les cha√Ænes vides ou les objets vides qui causent des erreurs MySQL
    if (result === '""' || result === '{}' || result === 'null') {
      return null
    }
    return result
  } catch (error) {
    console.error('Erreur de s√©rialisation JSON:', error)
    return null
  }
}

// Fonction utilitaire pour convertir une date en ISO string SANS conversion timezone
function toISOStringWithoutTimezone(date: Date): string {
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  const day = String(date.getDate()).padStart(2, '0')
  const hours = String(date.getHours()).padStart(2, '0')
  const minutes = String(date.getMinutes()).padStart(2, '0')
  const seconds = String(date.getSeconds()).padStart(2, '0')
  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}Z`
}

// Fonction utilitaire pour convertir une date ISO en format MySQL DATETIME SANS conversion de timezone
function formatDateForMySQL(isoDateString: string): string {
  try {
    const date = new Date(isoDateString)
    if (isNaN(date.getTime())) {
      throw new Error('Date invalide')
    }
    
    // Format MySQL DATETIME: YYYY-MM-DD HH:MM:SS
    // Utilisation directe sans conversion de timezone pour pr√©server l'heure exacte saisie
    return format(date, 'yyyy-MM-dd HH:mm:ss')
  } catch (error) {
    console.error('Erreur lors du formatage de la date pour MySQL:', error, 'Date:', isoDateString)
    // Retourner une date par d√©faut en cas d'erreur sans conversion de timezone
    return format(new Date(), 'yyyy-MM-dd HH:mm:ss')
  }
}

// Fonction utilitaire pour parser le JSON de mani√®re s√©curis√©e
function parseJsonSafe<T>(jsonString: string | null | undefined | any, defaultValue: T): T {
  try {
    if (!jsonString || jsonString === 'null' || jsonString === 'undefined') {
      return defaultValue
    }
    
    // Si c'est d√©j√† un objet (pas une cha√Æne), le retourner directement
    if (typeof jsonString === 'object') {
      return jsonString as T
    }
    
    // V√©rifier si c'est "[object Object]" - corruption courante
    if (jsonString === '[object Object]' || jsonString.includes('[object Object]')) {
      console.warn('Detected corrupted JSON string "[object Object]", using default value')
      return defaultValue
    }
    
    // Si la cha√Æne commence par "[object Object]" ou contient cette cha√Æne, essayer de la nettoyer
    if (typeof jsonString === 'string' && jsonString.includes('[object Object]')) {
      console.warn('Detected corrupted JSON with [object Object], using default value')
      return defaultValue
    }
    
    return JSON.parse(jsonString) as T
  } catch (error) {
    console.warn('Erreur lors du parsing JSON:', error, 'String:', jsonString)
    return defaultValue
  }
}

// ================================
// FONCTIONS CENTRALIS√âES POUR GESTION DES TIMESLOTS
// Synth√®se de toutes les modifications et corrections apport√©es
// ================================

// üéØ Fonctions Principales
// processTimeSlotEdition() - C≈ìur du traitement avec d√©tection automatique du mode
// prepareEventDataForSave() - Pr√©paration compl√®te des donn√©es pour sauvegarde
// üîß Fonctions Utilitaires
// validateTimeSlots() - Validation avec erreurs et avertissements
// hasOnlyTimeSlotsChanged() - D√©tection du type de modification
// prepareTimeSlotsForMoveAPI() - Format pour API de d√©placement
// initializeTimeSlotsFromEvent() - Initialisation depuis √©v√©nement existant

/**
 * Fonction centralis√©e pour traiter les TimeSlots en mode √©dition
 * D√©termine automatiquement le mode (simple/multiple) et traite les donn√©es
 */
export function processTimeSlotEdition(
  timeSlots: any[],
  originalEvent: any,
  userId: string,
  formData?: any
): {
  mode: 'single' | 'multiple';
  processedTimeSlots: TimeSlot[];
  logData: any;
} {
  // Filtrer les cr√©neaux actifs
  const activeTimeSlots = timeSlots.filter(slot => slot.status !== 'deleted')
  
  // D√©terminer le mode bas√© sur le nombre de cr√©neaux actifs r√©els
  const mode = activeTimeSlots.length > 1 ? 'multiple' : 'single'
  
  const currentDate = new Date().toISOString()
  
  // Log de d√©tection du mode
  const logData = {
    activeTimeSlotsCount: activeTimeSlots.length,
    mode: mode.toUpperCase(),
    modeChoisi: mode === 'multiple' ? 'MULTI-CRENEAUX' : 'CRENEAU-UNIQUE',
    timeSlots: activeTimeSlots
  }
  
  console.log('üîç [processTimeSlotEdition] D√©tection du mode:', logData)
  
  let processedTimeSlots: TimeSlot[] = []
  
  if (mode === 'multiple') {
    // Mode multi-cr√©neaux
    console.log('üîç [processTimeSlotEdition] Traitement mode MULTI-CRENEAUX')
    
    // D'abord, marquer tous les cr√©neaux existants comme supprim√©s
    if (originalEvent?.timeSlots) {
      originalEvent.timeSlots.forEach((existingSlot: any) => {
        if (existingSlot.status === 'active') {
          processedTimeSlots.push({
            ...existingSlot,
            status: 'deleted' as const,
            modifiedBy: [
              ...(existingSlot.modifiedBy || []),
              {
                userId,
                date: currentDate,
                action: 'deleted' as const
              }
            ]
          })
        } else {
          // Garder les slots d√©j√† supprim√©s
          processedTimeSlots.push(existingSlot)
        }
      })
    }
    
    // Ensuite, ajouter les nouveaux cr√©neaux
    activeTimeSlots.forEach((slot: any, slotIndex: number) => {
      if (slot.date && slot.startTime && slot.endTime) {
        // Cr√©er les dates sans d√©calage timezone - format local
        const dateStr = slot.date instanceof Date ? slot.date.toISOString().split('T')[0] : slot.date
        const startDateTime = new Date(`${dateStr}T${slot.startTime}:00`)
        const endDateTime = new Date(`${dateStr}T${slot.endTime}:00`)
        
        console.log(`üîç [processTimeSlotEdition] Traitement slot ${slotIndex}:`, {
          slotIndex,
          slotDate: slot.date,
          slotStartTime: slot.startTime,
          slotEndTime: slot.endTime,
          slotIsExisting: slot.isExisting,
          slotId: slot.id,
          slotStatus: slot.status,
          startDateTimeCalculated: toISOStringWithoutTimezone(startDateTime),
          endDateTimeCalculated: toISOStringWithoutTimezone(endDateTime)
        })
        
        if (slot.isExisting && slot.id) {
          // Si c'est un cr√©neau existant qu'on garde, on le marque comme modifi√©
          const existingSlot = originalEvent?.timeSlots?.find((s: any) => s.id === slot.id)
          
          console.log(`üîç [processTimeSlotEdition] Slot existant trouv√©:`, {
            existingSlotFound: !!existingSlot,
            existingSlotData: existingSlot,
            currentSlotData: slot,
            dateChanged: existingSlot ? existingSlot.startDate !== toISOStringWithoutTimezone(startDateTime) : 'N/A'
          })
          
          if (existingSlot) {
            processedTimeSlots.push({
              ...existingSlot,
              startDate: toISOStringWithoutTimezone(startDateTime),
              endDate: toISOStringWithoutTimezone(endDateTime),
              status: 'active' as const,
              modifiedBy: [
                ...(existingSlot.modifiedBy || []),
                {
                  userId,
                  date: currentDate,
                  action: 'modified' as const
                }
              ]
            })
          }
        } else {
          // Nouveau cr√©neau
          const newSlot = {
            id: generateTimeSlotId(),
            startDate: toISOStringWithoutTimezone(startDateTime),
            endDate: toISOStringWithoutTimezone(endDateTime),
            status: 'active' as const,
            createdBy: slot.createdBy || userId,
            modifiedBy: [{
              userId,
              date: currentDate,
              action: 'created' as const
            }]
          }
          
          console.log(`üîç [processTimeSlotEdition] Nouveau slot cr√©√©:`, {
            newSlotId: newSlot.id,
            startDateTime: newSlot.startDate,
            endDateTime: newSlot.endDate
          })
          
          processedTimeSlots.push(newSlot)
        }
      }
    })
    
  } else {
    // Mode cr√©neau unique (un seul cr√©neau actif)
    console.log('üîç [processTimeSlotEdition] Traitement mode CRENEAU-UNIQUE')
    
    const activeTimeSlot = activeTimeSlots[0]
    
    if (activeTimeSlot && activeTimeSlot.date && activeTimeSlot.startTime && activeTimeSlot.endTime) {
      console.log('üîç [processTimeSlotEdition] Mode cr√©neau unique - Slot utilis√©:', {
        activeTimeSlot,
        slotDate: activeTimeSlot.date,
        slotStartTime: activeTimeSlot.startTime,
        slotEndTime: activeTimeSlot.endTime,
        wasModified: activeTimeSlot.wasModified,
        isExisting: activeTimeSlot.isExisting
      })
      
      // Cr√©er les dates sans d√©calage timezone - format local
      const dateStr = activeTimeSlot.date instanceof Date ? activeTimeSlot.date.toISOString().split('T')[0] : activeTimeSlot.date
      const startDateTime = new Date(`${dateStr}T${activeTimeSlot.startTime}:00`)
      const endDateTime = new Date(`${dateStr}T${activeTimeSlot.endTime}:00`)
      
      // Marquer tous les anciens cr√©neaux comme supprim√©s
      if (originalEvent?.timeSlots) {
        originalEvent.timeSlots.forEach((slot: any) => {
          if (slot.status === 'active') {
            processedTimeSlots.push({
              ...slot,
              status: 'deleted' as const,
              modifiedBy: [
                ...(slot.modifiedBy || []),
                {
                  userId,
                  date: currentDate,
                  action: 'deleted' as const
                }
              ]
            })
          } else {
            processedTimeSlots.push(slot)
          }
        })
      }
      
      // Ajouter le nouveau cr√©neau
      const newSlot = {
        id: generateTimeSlotId(),
        startDate: startDateTime.toISOString(),
        endDate: toISOStringWithoutTimezone(endDateTime),
        status: 'active' as const,
        createdBy: userId,
        modifiedBy: [{
          userId,
          date: currentDate,
          action: 'created' as const
        }]
      }
      processedTimeSlots.push(newSlot)
      
      console.log('üîç [processTimeSlotEdition] Cr√©neau unique cr√©√©:', {
        originalSlotDate: activeTimeSlot.date,
        startDateTime,
        startDateTimeISO: toISOStringWithoutTimezone(startDateTime),
        endDateTime,
        endDateTimeISO: toISOStringWithoutTimezone(endDateTime),
        slotData: newSlot
      })
      
    } else if (formData?.startDate && formData?.startTime && formData?.endTime) {
      // Fallback vers formData si aucun timeSlot actif trouv√©
      console.warn('üîç [processTimeSlotEdition] FALLBACK - Aucun timeSlot actif, utilisation de formData')
      
      // Cr√©er les dates sans d√©calage timezone - format local
      const dateStr = formData.startDate instanceof Date ? formData.startDate.toISOString().split('T')[0] : formData.startDate
      const startDateTime = new Date(`${dateStr}T${formData.startTime}:00`)
      const endDateTime = new Date(`${dateStr}T${formData.endTime}:00`)
      
      // Marquer tous les anciens cr√©neaux comme supprim√©s
      if (originalEvent?.timeSlots) {
        originalEvent.timeSlots.forEach((slot: any) => {
          if (slot.status === 'active') {
            processedTimeSlots.push({
              ...slot,
              status: 'deleted' as const,
              modifiedBy: [
                ...(slot.modifiedBy || []),
                {
                  userId,
                  date: currentDate,
                  action: 'deleted' as const
                }
              ]
            })
          } else {
            processedTimeSlots.push(slot)
          }
        })
      }
      
      // Ajouter le nouveau cr√©neau
      const newSlot = {
        id: generateTimeSlotId(),
        startDate: startDateTime.toISOString(),
        endDate: toISOStringWithoutTimezone(endDateTime),
        status: 'active' as const,
        createdBy: userId,
        modifiedBy: [{
          userId,
          date: currentDate,
          action: 'created' as const
        }]
      }
      
      processedTimeSlots.push(newSlot)
    }
  }
  
  return {
    mode,
    processedTimeSlots,
    logData
  }
}

/**
 * Fonction pour pr√©parer les donn√©es d'√©v√©nement pour sauvegarde
 * Centralise toute la logique de pr√©paration des donn√©es
 */
export function prepareEventDataForSave(
  formData: any,
  timeSlots: any[],
  originalEvent: any,
  userId: string,
  files: any[] = [],
  remarks: string = ''
): {
  dataToSave: any;
  logData: any;
} {
  // Pr√©parer les donn√©es de base
  const baseData = {
    id: originalEvent?.id,
    title: formData.title,
    description: formData.description,
    state: formData.state,
    type: formData.type,
    class_data: formData.class_data,
    room: serializeRoomData(formData.room),
    location: formData.location,
    materials: formData.materials.map((mat: any) => ({
      ...mat,
      quantity: mat.quantity || 1
    })),
    chemicals: formData.chemicals.map((chem: any) => ({
      ...chem,
      requestedQuantity: chem.requestedQuantity || 1
    })),
    files: files.map(f => f.existingFile || f.file).filter(Boolean),
    remarks: remarks,
    updatedAt: new Date().toISOString()
  }
  
  // Log des donn√©es de base
  const baseLogData = {
    eventId: originalEvent?.id,
    title: formData.title,
    description: formData.description,
    type: formData.type,
    chemicalsCount: formData.chemicals.length,
    chemicalsData: formData.chemicals,
    materialsCount: formData.materials.length,
    materialsData: formData.materials,
    roomData: formData.room,
    classData: formData.class_data,
    timeSlotsCount: timeSlots.length,
    activeTimeSlots: timeSlots.filter(slot => slot.status !== 'deleted')
  }
  
  console.log('üîç [prepareEventDataForSave] Donn√©es de base pr√©par√©es:', baseLogData)
  
  // Traiter les TimeSlots
  const { mode, processedTimeSlots, logData } = processTimeSlotEdition(
    timeSlots,
    originalEvent,
    userId,
    formData
  )
  
  // Ajouter les TimeSlots aux donn√©es finales
  const dataToSave = {
    ...baseData,
    timeSlots: processedTimeSlots
  }
  
  // Log final des donn√©es
  const finalLogData = {
    eventId: dataToSave.id,
    title: dataToSave.title,
    timeSlotsCount: dataToSave.timeSlots?.length || 0,
    timeSlotsData: dataToSave.timeSlots,
    activeSlotsCount: dataToSave.timeSlots?.filter(slot => slot.status === 'active').length || 0,
    deletedSlotsCount: dataToSave.timeSlots?.filter(slot => slot.status === 'deleted').length || 0,
    chemicalsData: dataToSave.chemicals,
    materialsData: dataToSave.materials,
    mode,
    completeDataToSave: dataToSave
  }
  
  console.log('üîç [prepareEventDataForSave] Donn√©es finales avec timeSlots:', finalLogData)
  
  return {
    dataToSave,
    logData: {
      base: baseLogData,
      processing: logData,
      final: finalLogData
    }
  }
}

/**
 * Fonction pour d√©terminer si seuls les cr√©neaux horaires ont chang√©
 * Utilis√©e pour d√©cider entre modification directe ou proposition de d√©placement
 */
export function hasOnlyTimeSlotsChanged(
  formData: any,
  originalEvent: any
): boolean {
  if (!originalEvent) return false
  
  return (
    formData.title === originalEvent.title &&
    formData.description === originalEvent.description &&
    formData.type === originalEvent.type &&
    JSON.stringify(formData.class_data) === JSON.stringify(originalEvent.class_data) &&
    compareRoomData(formData.room, originalEvent.room) &&
    formData.location === originalEvent.location &&
    JSON.stringify(formData.chemicals) === JSON.stringify(originalEvent.chemicals || []) &&
    JSON.stringify(formData.materials) === JSON.stringify(originalEvent.materials || [])
  )
}

/**
 * Fonction pour pr√©parer les cr√©neaux pour l'API de d√©placement
 */
export function prepareTimeSlotsForMoveAPI(timeSlots: any[]): any[] {
  return timeSlots
    .filter(slot => slot.date && slot.startTime && slot.endTime && slot.status !== 'deleted')
    .map(slot => ({
      date: slot.date!.toISOString().split('T')[0],
      startTime: slot.startTime,
      endTime: slot.endTime
    }))
}

/**
 * Fonction utilitaire pour valider les cr√©neaux horaires
 */
export function validateTimeSlots(timeSlots: any[]): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = []
  const warnings: string[] = []
  const activeSlots = timeSlots.filter(slot => slot.status !== 'deleted')
  
  if (activeSlots.length === 0) {
    errors.push('Au moins un cr√©neau horaire valide est requis')
  }
  
  // V√©rifier chaque cr√©neau
  activeSlots.forEach((slot, index) => {
    if (!slot.date) {
      errors.push(`Cr√©neau ${index + 1} : Date manquante`)
    }
    if (!slot.startTime) {
      errors.push(`Cr√©neau ${index + 1} : Heure de d√©but manquante`)
    }
    if (!slot.endTime) {
      errors.push(`Cr√©neau ${index + 1} : Heure de fin manquante`)
    }
    
    // V√©rifier les heures d'ouverture
    if (slot.startTime) {
      const [startHour] = slot.startTime.split(':').map(Number)
      if (startHour < 8) {
        warnings.push(`Cr√©neau ${index + 1} : d√©but avant 8h00`)
      }
    }
    
    if (slot.endTime) {
      const [endHour, endMinute] = slot.endTime.split(':').map(Number)
      if (endHour > 19 || (endHour === 19 && endMinute > 0)) {
        warnings.push(`Cr√©neau ${index + 1} : fin apr√®s 19h00`)
      }
    }
    
    // V√©rifier que l'heure de fin est apr√®s l'heure de d√©but
    if (slot.startTime && slot.endTime) {
      const start = new Date(`2000-01-01T${slot.startTime}`)
      const end = new Date(`2000-01-01T${slot.endTime}`)
      if (end <= start) {
        errors.push(`Cr√©neau ${index + 1} : l'heure de fin doit √™tre apr√®s l'heure de d√©but`)
      }
    }
  })
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  }
}


/**
 * Fonction pour initialiser les TimeSlots depuis un √©v√©nement existant
 * Utilis√©e dans l'initialisation des composants d'√©dition
 */
export function initializeTimeSlotsFromEvent(event: any): {
  timeSlots: any[];
  showMultipleSlots: boolean;
  firstSlotData: {
    startDate: Date;
    endDate: Date;
    startTime: string;
    endTime: string;
  } | null;
} {
  if (!event) {
    return {
      timeSlots: [],
      showMultipleSlots: false,
      firstSlotData: null
    }
  }
  
  // Fonction pour obtenir les cr√©neaux actifs (doit √™tre import√©e ou red√©finie)
  const getActiveTimeSlots = (evt: any) => {
    if (evt.actuelTimeSlots && Array.isArray(evt.actuelTimeSlots)) {
      return evt.actuelTimeSlots.filter((slot: any) => slot.status === 'active')
    }
    if (evt.timeSlots && Array.isArray(evt.timeSlots)) {
      return evt.timeSlots.filter((slot: any) => slot.status === 'active')
    }
    // Fallback : cr√©er un slot depuis les dates de l'√©v√©nement
    return [{
      id: `${evt.id}-fallback`,
      startDate: evt.start_date,
      endDate: evt.end_date,
      status: 'active'
    }]
  }
  
  const activeSlots = getActiveTimeSlots(event)
  const firstSlot = activeSlots[0]
  
  if (!firstSlot) {
    console.warn('Aucun cr√©neau actif trouv√© pour l\'√©v√©nement')
    return {
      timeSlots: [],
      showMultipleSlots: false,
      firstSlotData: null
    }
  }
  
  const startDate = new Date(firstSlot.startDate)
  const endDate = new Date(firstSlot.endDate)
  
  // Formater les TimeSlots avec conservation de l'historique
  const formattedTimeSlots = activeSlots.map((slot: any) => ({
    id: slot.id,
    date: new Date(slot.startDate),
    startTime: new Date(slot.startDate).toLocaleTimeString('fr-FR', { 
      hour: '2-digit', 
      minute: '2-digit', 
      hour12: false 
    }),
    endTime: new Date(slot.endDate).toLocaleTimeString('fr-FR', { 
      hour: '2-digit', 
      minute: '2-digit', 
      hour12: false 
    }),
    status: (slot.status || 'active') as 'active' | 'deleted' | 'cancelled',
    isExisting: true,
    wasModified: false,
    originalData: {
      date: new Date(slot.startDate),
      startTime: new Date(slot.startDate).toLocaleTimeString('fr-FR', { 
        hour: '2-digit', 
        minute: '2-digit', 
        hour12: false 
      }),
      endTime: new Date(slot.endDate).toLocaleTimeString('fr-FR', { 
        hour: '2-digit', 
        minute: '2-digit', 
        hour12: false 
      })
    },
    createdBy: slot.createdBy,
    modifiedBy: slot.modifiedBy || []
  }))
  
  return {
    timeSlots: formattedTimeSlots,
    showMultipleSlots: activeSlots.length > 1,
    firstSlotData: {
      startDate,
      endDate,
      startTime: startDate.toLocaleTimeString('fr-FR', { 
        hour: '2-digit', 
        minute: '2-digit', 
        hour12: false 
      }),
      endTime: endDate.toLocaleTimeString('fr-FR', { 
        hour: '2-digit', 
        minute: '2-digit', 
        hour12: false 
      })
    }
  }
}

// Fonction utilitaire pour transformer les mat√©riaux/√©quipements
function transformMaterials(rawData: any[]): any[] {
  // V√©rifier que rawData est bien un array
  if (!Array.isArray(rawData)) {
    console.warn('transformMaterials: rawData n\'est pas un array:', rawData);
    return [];
  }
  
  return rawData.map((item: any) => {
    if (typeof item === 'string') {
      return { id: item, name: item };
    }
    return {
      id: item.id || item,
      name: item.name || item.itemName || (typeof item === 'string' ? item : 'Mat√©riel'),
      itemName: item.itemName || item.name,
      quantity: item.quantity || 1,
      volume: item.volume,
      isCustom: item.isCustom || false
    };
  });
}

// Fonction utilitaire pour transformer les produits chimiques/consommables
function transformChemicals(rawData: any[], discipline = 'chimie'): any[] {
  // V√©rifier que rawData est bien un array
  if (!Array.isArray(rawData)) {
    console.warn('transformChemicals: rawData n\'est pas un array:', rawData);
    return [];
  }
  
  return rawData.map((item: any) => {
    if (typeof item === 'string') {
      return { id: item, name: item };
    }
    return {
      id: item.id || item,
      name: item.name || (typeof item === 'string' ? item : (discipline === 'physique' ? 'Consommable' : 'R√©actif')),
      requestedQuantity: item.requestedQuantity || 1,
      quantity: item.quantity,
      unit: item.unit,
      isCustom: item.isCustom || false,
      ...(discipline === 'chimie' ? { formula: item.formula } : {})
    };
  });
}

// Types pour les √©v√©nements de calendrier avec le nouveau syst√®me TimeSlots
export interface CalendarEventWithTimeSlots {
  id: string
  title: string
  start_date: string
  end_date: string
  description?: string
  type: 'tp' | 'cours' | 'exam' | 'maintenance' | 'reservation' | 'other'
  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled'
  state?: 'PENDING' | 'VALIDATED' | 'CANCELLED' | 'MOVED' | 'IN_PROGRESS'
  room?: RoomData | null // Support pour string legacy et nouveau format objet
  teacher?: string
  class_data?: {
    id: string
    name: string
    type: 'predefined' | 'custom' | 'auto'
  } | null
  participants?: string[] // Will be stored as JSON
  equipment_used?: string[] // Will be stored as JSON
  chemicals_used?: string[] // Will be stored as JSON
  consommables_used?: string[] // Will be stored as JSON
  notes?: string
  color?: string
  createdBy: string
  created_at?: string
  updated_at?: string
  timeSlots?: TimeSlot[] // Array des TimeSlots propos√©s/modifi√©s
  actuelTimeSlots?: TimeSlot[] // Array des TimeSlots actuels accept√©s par l'owner
  stateChangeReason?: string
  lastStateChange?: {
    from: string
    to: string
    date: string
    userId: string
    reason?: string
  } | null
  validationState?: 'noPending' | 'ownerPending' | 'operatorPending'
}

// Fonction pour obtenir tous les √©v√©nements de chimie avec les nouveaux champs
export async function getChemistryEventsWithTimeSlots(startDate?: string, endDate?: string): Promise<CalendarEventWithTimeSlots[]> {
  try {
    let query = `
      SELECT 
        c.*,
        u.name as creator_name,
        u.email as creator_email
      FROM calendar_chimie c
      LEFT JOIN users u ON c.created_by = u.id
    `
    const params: any[] = []
    
    if (startDate && endDate) {
      query += ' WHERE c.start_date >= ? AND c.end_date <= ?'
      params.push(startDate, endDate)
    } else if (startDate) {
      query += ' WHERE c.start_date >= ?'
      params.push(startDate)
    } else if (endDate) {
      query += ' WHERE c.end_date <= ?'
      params.push(endDate)
    }
    
    query += ' ORDER BY c.start_date ASC'
    
    const [rows] = await pool.execute(query, params)
    
    // Pour chaque √©v√©nement, r√©cup√©rer ses cr√©neaux depuis la nouvelle table
    const eventsWithTimeslots = await Promise.all((rows as any[]).map(async (row) => {
      // R√©cup√©rer les cr√©neaux depuis la table calendar_timeslots
      let timeSlots: any[] = []
      let actuelTimeSlots: any[] = []
      
      try {
        const timeslots = await getTimeslotsByEventId(row.id, 'chimie')
        
        // Convertir les TimeslotData vers le format TimeSlot attendu par les composants
        timeSlots = timeslots.map(slot => ({
          id: slot.id,
          startDate: new Date(slot.start_date).toISOString(),
          endDate: new Date(slot.end_date).toISOString(),
          status: 'active' as const,
          createdBy: slot.user_id,
          modifiedBy: [{
            userId: slot.user_id,
            date: new Date(slot.created_at).toISOString(),
            action: 'created' as const
          }]
        }))
        
        // Les cr√©neaux actuels sont tous les cr√©neaux approuv√©s ou cr√©√©s
        actuelTimeSlots = timeSlots.filter((_, index) => 
          ['approved', 'created'].includes(timeslots[index].state)
        )
        
        // Fallback vers l'ancien syst√®me si aucun cr√©neau trouv√© dans la nouvelle table
        if (timeSlots.length === 0) {
          // Essayer de r√©cup√©rer depuis les anciens champs JSON (compatibilit√©)
          const legacyTimeSlots = parseJsonSafe(row.timeSlots, [])
          const legacyActuelTimeSlots = parseJsonSafe(row.actuelTimeSlots, [])
          
          if (legacyTimeSlots.length > 0) {
            timeSlots = legacyTimeSlots
            actuelTimeSlots = legacyActuelTimeSlots
          } else {
            // Cr√©er un cr√©neau par d√©faut depuis start_date/end_date
            const defaultSlot: TimeSlot = {
              id: `${row.id}-default`,
              startDate: row.start_date,
              endDate: row.end_date,
              status: 'active',
              createdBy: row.created_by
            }
            timeSlots = [defaultSlot]
            actuelTimeSlots = [defaultSlot]
          }
        }
      } catch (error) {
        console.error('Erreur r√©cup√©ration cr√©neaux pour √©v√©nement', row.id, error)
        throw new Error(`Impossible de r√©cup√©rer les cr√©neaux pour l'√©v√©nement ${row.id}: ${error instanceof Error ? error.message : 'Erreur inconnue'}`)
      }

      return {
        id: row.id,
        title: row.title,
        start_date: row.start_date,
        end_date: row.end_date,
        description: row.description,
        type: row.type,
        status: row.status,
        state: row.state || 'VALIDATED',
        room: normalizeRoomData(row.room), // Normaliser les donn√©es de salle
        teacher: row.teacher,
        class_data: parseJsonSafe(row.class_data, null), // Nouveau champ
        participants: parseJsonSafe(row.participants, []),
        equipment_used: transformMaterials(parseJsonSafe(row.equipment_used, [])),
        chemicals_used: transformChemicals(parseJsonSafe(row.chemicals_used, []), 'chimie'),
        notes: row.notes,
        color: row.color,
        createdBy: row.created_by,
        created_by: row.created_by,
        creator_name: row.creator_name, // Nouveau champ depuis le JOIN
        creator_email: row.creator_email, // Nouveau champ depuis le JOIN
        created_at: row.created_at,
        updated_at: row.updated_at,
        timeSlots,
        actuelTimeSlots,
        stateChangeReason: row.stateChangeReason,
        lastStateChange: parseJsonSafe(row.lastStateChange, null),
        validationState: row.validationState
      }
    }))
    
    return eventsWithTimeslots
    
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des √©v√©nements de chimie:', error)
    throw error
  }
}

// Fonction pour cr√©er un √©v√©nement de chimie avec les nouveaux champs
export async function createChemistryEventWithTimeSlots(eventData: Partial<CalendarEventWithTimeSlots>): Promise<CalendarEventWithTimeSlots> {
  try {
    // Validation des donn√©es requises
    if (!eventData.createdBy) {
      throw new Error('Le champ createdBy est requis pour cr√©er un √©v√©nement')
    }
    
    const id = uuidv4()
    
    // 1. Cr√©er l'√©v√©nement principal dans calendar_chimie (sans les timeSlots dans les colonnes JSON)
    const query = `
      INSERT INTO calendar_chimie (
        id, title, start_date, end_date, description, type, status, state,
        room, teacher, class_data, participants, equipment_used, chemicals_used,
        notes, color, created_by, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `
    
    // Debug logging
    console.log('DEBUG createChemistryEventWithTimeSlots - eventData.createdBy:', eventData.createdBy)
    console.log('DEBUG createChemistryEventWithTimeSlots - typeof eventData.createdBy:', typeof eventData.createdBy)

    const params = [
      id,
      eventData.title || '',
      eventData.start_date ? formatDateForMySQL(eventData.start_date) : '',
      eventData.end_date ? formatDateForMySQL(eventData.end_date) : '',
      eventData.description || '',
      eventData.type || 'other',
      eventData.status || 'scheduled',
      eventData.state || 'VALIDATED',
      safeJsonStringify(normalizeRoomData(eventData.room)), // S√©rialisation s√©curis√©e des donn√©es de salle
      eventData.teacher || '',
      safeJsonStringify(eventData.class_data),
      safeJsonStringify(eventData.participants || []),
      safeJsonStringify(eventData.equipment_used || []),
      safeJsonStringify(eventData.chemicals_used || []),
      eventData.notes || '',
      eventData.color || '#2196f3',
      eventData.createdBy! // ! car d√©j√† valid√© plus haut
    ]
    
    console.log('DEBUG createChemistryEventWithTimeSlots - createdBy param (index 16):', params[16])
    
    await pool.execute(query, params)
    
    // 2. Cr√©er les cr√©neaux dans la table calendar_timeslots si fournis
    if (eventData.timeSlots && Array.isArray(eventData.timeSlots) && eventData.timeSlots.length > 0) {
      const timeslotProposals: TimeslotProposal[] = eventData.timeSlots.map((slot: any) => {
        // Convertir le format timeSlot vers TimeslotProposal
        let startDate: string, endDate: string, timeslotDate: string
        
        if (slot.date && slot.startTime && slot.endTime) {
          // Format CreateTPDialog: { date, startTime, endTime }
          startDate = `${slot.date}T${slot.startTime}:00`
          endDate = `${slot.date}T${slot.endTime}:00`
          timeslotDate = slot.date
        } else if (slot.startDate && slot.endDate) {
          // Format TimeSlot: { startDate, endDate }
          startDate = slot.startDate
          endDate = slot.endDate
          timeslotDate = slot.startDate.split('T')[0]
        } else {
          throw new Error('Format de cr√©neau invalide')
        }
        
        return {
          event_id: id,
          discipline: 'chimie' as Discipline,
          user_id: eventData.createdBy!, // ! car d√©j√† valid√© plus haut
          start_date: startDate,
          end_date: endDate,
          timeslot_date: timeslotDate,
          action: 'create' as const,
          notes: slot.notes || 'Cr√©neau cr√©√© automatiquement'
        }
      })
      
      // Cr√©er les cr√©neaux via la nouvelle API
      await proposeNewTimeslots(
        id,
        'chimie',
        eventData.createdBy!, // ! car d√©j√† valid√© plus haut
        eventData.createdBy!, // event_owner - ! car d√©j√† valid√© plus haut
        timeslotProposals
      )
    }
    
    // 3. R√©cup√©rer l'√©v√©nement cr√©√© avec ses cr√©neaux
    const [rows] = await pool.execute('SELECT * FROM calendar_chimie WHERE id = ?', [id])
    const createdEvent = (rows as any[])[0]
    
    // R√©cup√©rer les cr√©neaux depuis la nouvelle table
    const timeslots = await getTimeslotsByEventId(id, 'chimie')
    
    // Convertir les TimeslotData vers le format TimeSlot attendu par les composants
    const convertedTimeSlots = timeslots.map(slot => ({
      id: slot.id,
      startDate: new Date(slot.start_date).toISOString(),
      endDate: new Date(slot.end_date).toISOString(),
      status: 'active' as const,
      createdBy: slot.user_id,
      modifiedBy: [{
        userId: slot.user_id,
        date: new Date(slot.created_at).toISOString(),
        action: 'created' as const
      }]
    }))
    
    return {
      ...createdEvent,
      timeSlots: convertedTimeSlots, // Cr√©neaux depuis la nouvelle table
      actuelTimeSlots: convertedTimeSlots.filter((_, index) => 
        ['approved', 'created'].includes(timeslots[index].state)
      ), // Cr√©neaux approuv√©s
      lastStateChange: null,
      room: normalizeRoomData(createdEvent.room),
      class_data: parseJsonSafe(createdEvent.class_data, null),
      participants: parseJsonSafe(createdEvent.participants, []),
      equipment_used: transformMaterials(parseJsonSafe(createdEvent.equipment_used, [])),
      chemicals_used: transformChemicals(parseJsonSafe(createdEvent.chemicals_used, []), 'chimie')
    }
    
  } catch (error) {
    console.error('Erreur lors de la cr√©ation de l\'√©v√©nement de chimie:', error)
    throw error
  }
}

// Fonction pour mettre √† jour un √©v√©nement de chimie avec les nouveaux champs
export async function updateChemistryEventWithTimeSlots(
  id: string, 
  eventData: Partial<CalendarEventWithTimeSlots>
): Promise<CalendarEventWithTimeSlots> {
  try {
    // Convertir 'class' vers 'class_data' si n√©cessaire
    const processedEventData = { ...eventData } as any
    if ((eventData as any).class && Array.isArray((eventData as any).class) && (eventData as any).class.length > 0) {
      processedEventData.class_data = (eventData as any).class[0] // Prendre le premier √©l√©ment du tableau
      delete processedEventData.class // Supprimer l'ancien champ
    }
    
    // Mapping des champs API vers les colonnes de la base de donn√©es
    if (processedEventData.materials !== undefined) {
      processedEventData.equipment_used = processedEventData.materials
      delete processedEventData.materials
    }
    if (processedEventData.chemicals !== undefined) {
      processedEventData.chemicals_used = processedEventData.chemicals
      delete processedEventData.chemicals
    }
    if (processedEventData.remarks !== undefined) {
      processedEventData.notes = processedEventData.remarks
      delete processedEventData.remarks
    }
    // Ignorer les champs qui n'existent pas dans la table
    const fieldsToIgnore = ['files', 'location']
    fieldsToIgnore.forEach(field => {
      if (processedEventData[field] !== undefined) {
        delete processedEventData[field]
      }
    })
    
    const updates: string[] = []
    const params: any[] = []
    
    // Construire la requ√™te de mise √† jour dynamiquement
    Object.entries(processedEventData).forEach(([key, value]) => {
      if (key === 'id') return // Skip ID
      
      if (key === 'timeSlots' || key === 'actuelTimeSlots' || key === 'lastStateChange') {
        // Champs JSON - traiter comme des objets
        updates.push(`${key} = ?`)
        params.push(JSON.stringify(value))
      } else if (key === 'participants' || key === 'equipment_used' || key === 'chemicals_used') {
        // Champs JSON
        updates.push(`${key} = ?`)
        params.push(JSON.stringify(value))
      } else if (key === 'start_date' || key === 'end_date') {
        // Formater les dates pour MySQL (exclure updated_at car trait√© s√©par√©ment)
        updates.push(`${key} = ?`)
        params.push(value ? formatDateForMySQL(value as string) : value)
      } else if (key === 'updated_at') {
        // Traiter updated_at s√©par√©ment
        updates.push(`${key} = ?`)
        params.push(value ? formatDateForMySQL(value as string) : value)
      } else if (key === 'room') {
        // Traiter les donn√©es de salle sp√©cialement
        updates.push(`${key} = ?`)
        params.push(safeJsonStringify(normalizeRoomData(value as string | RoomData)))
      } else if (key === 'validationState') {
        // Champ enum pour le statut de validation
        updates.push(`${key} = ?`)
        params.push(value)
      } else {
        // Autres champs texte/nombre (y compris class_data et autres JSON)
        updates.push(`${key} = ?`)
        if (['class_data', 'equipment_used', 'chemicals_used', 'timeSlots', 'actuelTimeSlots', 'lastStateChange', 'participants'].includes(key)) {
          params.push(safeJsonStringify(value))
        } else {
          params.push(value)
        }
      }
    })
    
    if (updates.length === 0) {
      throw new Error('Aucune mise √† jour sp√©cifi√©e')
    }
    
    // Ajouter updated_at = NOW() seulement si pas d√©j√† fourni dans processedEventData
    if (!processedEventData.hasOwnProperty('updated_at')) {
      updates.push('updated_at = NOW()')
    }
    
    params.push(id)
    
    const query = `UPDATE calendar_chimie SET ${updates.join(', ')} WHERE id = ?`
    
    await pool.execute(query, params)
    
    // Retourner l'√©v√©nement mis √† jour
    const [rows] = await pool.execute('SELECT * FROM calendar_chimie WHERE id = ?', [id])
    const updatedEvent = (rows as any[])[0]
    
    if (!updatedEvent) {
      throw new Error('√âv√©nement non trouv√© apr√®s mise √† jour')
    }
    
    return {
      ...updatedEvent,
      timeSlots: parseJsonSafe(updatedEvent.timeSlots, []),
      actuelTimeSlots: parseJsonSafe(updatedEvent.actuelTimeSlots, []),
      lastStateChange: parseJsonSafe(updatedEvent.lastStateChange, null)
    }
    
  } catch (error) {
    console.error('Erreur lors de la mise √† jour de l\'√©v√©nement de chimie:', error)
    throw error
  }
}

// Fonction pour obtenir un √©v√©nement de chimie par ID avec les nouveaux champs
export async function getChemistryEventByIdWithTimeSlots(id: string): Promise<CalendarEventWithTimeSlots | null> {
  try {
    const [rows] = await pool.execute('SELECT * FROM calendar_chimie WHERE id = ?', [id])
    const events = rows as any[]
    
    if (events.length === 0) {
      return null
    }
    
    const row = events[0]
    
    return {
      ...row,
      timeSlots: parseJsonSafe(row.timeSlots, []),
      actuelTimeSlots: parseJsonSafe(row.actuelTimeSlots, []),
      lastStateChange: parseJsonSafe(row.lastStateChange, null),
      participants: parseJsonSafe(row.participants, []),
      equipment_used: transformMaterials(parseJsonSafe(row.equipment_used, [])),
      chemicals_used: transformChemicals(parseJsonSafe(row.chemicals_used, []), 'chimie')
    }
    
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration de l\'√©v√©nement de chimie:', error)
    throw error
  }
}

// ============================================================================
// FONCTIONS PHYSIQUE - √âquivalentes aux fonctions chimie pour table calendar_physique
// ============================================================================

// Fonction pour obtenir tous les √©v√©nements de physique avec les nouveaux champs
export async function getPhysicsEventsWithTimeSlots(startDate?: string, endDate?: string): Promise<CalendarEventWithTimeSlots[]> {
  try {
    let query = `
      SELECT 
        p.*,
        u.name as creator_name,
        u.email as creator_email
      FROM calendar_physique p
      LEFT JOIN users u ON p.created_by = u.id
    `
    const params: any[] = []
    
    if (startDate && endDate) {
      query += ' WHERE p.start_date >= ? AND p.end_date <= ?'
      params.push(startDate, endDate)
    }
    
    query += ' ORDER BY p.start_date ASC'
    
    const [rows] = await pool.execute(query, params)
    
    return (rows as any[]).map(row => ({
      id: row.id,
      title: row.title,
      start_date: row.start_date,
      end_date: row.end_date,
      description: row.description,
      type: row.type,
      status: row.status,
      state: row.state,
      room: normalizeRoomData(row.room), // Normaliser les donn√©es de salle
      teacher: row.teacher,
      class_data: row.class_data,
      notes: row.notes,
      color: row.color,
      createdBy: row.created_by,
      created_by: row.created_by,
      creator_name: row.creator_name, // Nouveau champ depuis le JOIN
      creator_email: row.creator_email, // Nouveau champ depuis le JOIN
      created_at: row.created_at,
      updated_at: row.updated_at,
      stateChangeReason: row.stateChangeReason,
      
      // Parser les champs JSON en toute s√©curit√©
      timeSlots: parseJsonSafe(row.timeSlots, []),
      actuelTimeSlots: parseJsonSafe(row.actuelTimeSlots, []),
      lastStateChange: parseJsonSafe(row.lastStateChange, null),
      participants: parseJsonSafe(row.participants, []),
      equipment_used: transformMaterials(parseJsonSafe(row.equipment_used, [])),
      consommables_used: transformChemicals(parseJsonSafe(row.consommables_used, []), 'physique')
    }))
    
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des √©v√©nements de physique avec TimeSlots:', error)
    throw error
  }
}

// Fonction pour cr√©er un √©v√©nement de physique avec le syst√®me TimeSlots
export async function createPhysicsEventWithTimeSlots(eventData: Partial<CalendarEventWithTimeSlots>): Promise<CalendarEventWithTimeSlots> {
  try {
    // G√©n√©rer un ID unique pour l'√©v√©nement
    const eventId = uuidv4()
    
    // Pr√©parer les donn√©es avec les valeurs par d√©faut
    const finalEventData = {
      id: eventId,
      title: eventData.title || '',
      start_date: eventData.start_date ? formatDateForMySQL(eventData.start_date) : formatDateForMySQL(new Date().toISOString()),
      end_date: eventData.end_date ? formatDateForMySQL(eventData.end_date) : formatDateForMySQL(new Date().toISOString()),
      description: eventData.description || '',
      type: eventData.type || 'other',
      status: eventData.status || 'scheduled',
      state: eventData.state || 'VALIDATED',
      room: safeJsonStringify(normalizeRoomData(eventData.room)), // S√©rialisation s√©curis√©e
      teacher: eventData.teacher || '',
      class_data: safeJsonStringify(eventData.class_data),
      notes: eventData.notes || '',
      color: eventData.color || '#2196f3',
      created_by: eventData.createdBy || '',
      stateChangeReason: eventData.stateChangeReason || '',
      
      // S√©rialiser les champs JSON
      participants: safeJsonStringify(eventData.participants || []),
      equipment_used: safeJsonStringify(eventData.equipment_used || []),
      consommables_used: safeJsonStringify(eventData.consommables_used || []),
      timeSlots: safeJsonStringify(eventData.timeSlots || []),
      actuelTimeSlots: safeJsonStringify(eventData.actuelTimeSlots || []),
      lastStateChange: safeJsonStringify(eventData.lastStateChange)
    }
    
    // Construire la requ√™te d'insertion
    const fields = Object.keys(finalEventData)
    const placeholders = fields.map(() => '?').join(', ')
    const query = `
      INSERT INTO calendar_physique (${fields.join(', ')})
      VALUES (${placeholders})
    `
    
    const values = Object.values(finalEventData)
    
    await pool.execute(query, values)
    
    // Retourner l'√©v√©nement cr√©√© avec les donn√©es pars√©es
    return {
      ...finalEventData,
      createdBy: eventData.createdBy || '',
      room: normalizeRoomData(eventData.room), // Retourner l'objet room normalis√©
      class_data: eventData.class_data || null, // Retourner les donn√©es class originales
      participants: eventData.participants || [],
      equipment_used: eventData.equipment_used || [],
      consommables_used: eventData.consommables_used || [],
      timeSlots: eventData.timeSlots || [],
      actuelTimeSlots: eventData.actuelTimeSlots || [],
      lastStateChange: eventData.lastStateChange || undefined
    }
    
  } catch (error) {
    console.error('Erreur lors de la cr√©ation de l\'√©v√©nement de physique avec TimeSlots:', error)
    throw error
  }
}

// Fonction pour mettre √† jour un √©v√©nement de physique avec le syst√®me TimeSlots
export async function updatePhysicsEventWithTimeSlots(id: string, updateData: Partial<CalendarEventWithTimeSlots>): Promise<CalendarEventWithTimeSlots> {
  try {
    // Convertir 'class' vers 'class_data' si n√©cessaire
    const processedUpdateData = { ...updateData } as any
    if ((updateData as any).class && Array.isArray((updateData as any).class) && (updateData as any).class.length > 0) {
      processedUpdateData.class_data = (updateData as any).class[0] // Prendre le premier √©l√©ment du tableau
      delete processedUpdateData.class // Supprimer l'ancien champ
    }
    
    // Pr√©parer les donn√©es de mise √† jour
    const updateFields: string[] = []
    const updateValues: any[] = []
    
    // Champs simples
    const simpleFields = ['title', 'start_date', 'end_date', 'description', 'type', 'status', 'state', 'room', 'teacher', 'class_data', 'notes', 'color', 'stateChangeReason', 'validationState']
    
    simpleFields.forEach(field => {
      if (processedUpdateData[field as keyof CalendarEventWithTimeSlots] !== undefined) {
        updateFields.push(`${field} = ?`)
        
        // Formater les dates pour MySQL
        if (field === 'start_date' || field === 'end_date') {
          const dateValue = processedUpdateData[field as keyof CalendarEventWithTimeSlots] as string
          updateValues.push(dateValue ? formatDateForMySQL(dateValue) : dateValue)
        } else if (field === 'room') {
          // Traiter les donn√©es de salle sp√©cialement
          const roomValue = processedUpdateData[field as keyof CalendarEventWithTimeSlots] as string | RoomData
          updateValues.push(safeJsonStringify(normalizeRoomData(roomValue)))
        } else if (['class_data'].includes(field)) {
          // Traiter les champs JSON simples
          updateValues.push(safeJsonStringify(processedUpdateData[field]))
        } else {
          updateValues.push(processedUpdateData[field as keyof CalendarEventWithTimeSlots])
        }
      }
    })
    
    // G√©rer updated_at s√©par√©ment s'il est fourni
    if (processedUpdateData.updated_at !== undefined) {
      updateFields.push('updated_at = ?')
      updateValues.push(formatDateForMySQL(processedUpdateData.updated_at as string))
    }
    
    // Champs JSON
    const jsonFields = ['participants', 'equipment_used', 'consommables_used', 'timeSlots', 'actuelTimeSlots', 'lastStateChange']
    
    jsonFields.forEach(field => {
      if (processedUpdateData[field as keyof CalendarEventWithTimeSlots] !== undefined) {
        updateFields.push(`${field} = ?`)
        updateValues.push(JSON.stringify(processedUpdateData[field as keyof CalendarEventWithTimeSlots]))
      }
    })
    
    // Ajouter updated_at = NOW() seulement si pas d√©j√† fourni
    if (processedUpdateData.updated_at === undefined) {
      updateFields.push('updated_at = NOW()')
    }
    
    if (updateFields.length === 0) {
      throw new Error('Aucune donn√©e √† mettre √† jour')
    }
    
    // Construire et ex√©cuter la requ√™te de mise √† jour
    const query = `
      UPDATE calendar_physique 
      SET ${updateFields.join(', ')}
      WHERE id = ?
    `
    
    updateValues.push(id)
    
    await pool.execute(query, updateValues)
    
    // R√©cup√©rer et retourner l'√©v√©nement mis √† jour
    return await getPhysicsEventByIdWithTimeSlots(id)
    
  } catch (error) {
    console.error('Erreur lors de la mise √† jour de l\'√©v√©nement de physique avec TimeSlots:', error)
    throw error
  }
}

// Fonction pour r√©cup√©rer un √©v√©nement de physique par ID avec le syst√®me TimeSlots
export async function getPhysicsEventByIdWithTimeSlots(id: string): Promise<CalendarEventWithTimeSlots> {
  try {
    const query = 'SELECT * FROM calendar_physique WHERE id = ?'
    const [rows] = await pool.execute(query, [id])
    
    if (!Array.isArray(rows) || rows.length === 0) {
      throw new Error('√âv√©nement de physique non trouv√©')
    }
    
    const row = (rows as any[])[0]
    
    return {
      id: row.id,
      title: row.title,
      start_date: row.start_date,
      end_date: row.end_date,
      description: row.description,
      type: row.type,
      status: row.status,
      state: row.state,
      room: row.room,
      teacher: row.teacher,
      class_data: parseJsonSafe(row.class_data, null), // Nouveau champ
      notes: row.notes,
      color: row.color,
      createdBy: row.created_by,
      created_at: row.created_at,
      updated_at: row.updated_at,
      stateChangeReason: row.stateChangeReason,
      
      // Parser les champs JSON en toute s√©curit√©
      timeSlots: parseJsonSafe(row.timeSlots, []),
      actuelTimeSlots: parseJsonSafe(row.actuelTimeSlots, []),
      lastStateChange: parseJsonSafe(row.lastStateChange, null),
      participants: parseJsonSafe(row.participants, []),
      equipment_used: transformMaterials(parseJsonSafe(row.equipment_used, [])),
      consommables_used: transformChemicals(parseJsonSafe(row.consommables_used, []), 'physique')
    }
    
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration de l\'√©v√©nement de physique:', error)
    throw error
  }
}

// Fonction utilitaire pour comparer deux TimeSlots et d√©terminer s'ils ont √©t√© modifi√©s
export function hasTimeSlotChanged(originalSlot: any, newSlot: any): boolean {
  if (!originalSlot || !newSlot) return true
  
  // Comparer les propri√©t√©s importantes (exclure id et modifiedBy)
  const fieldsToCompare = ['startDate', 'endDate', 'status', 'room', 'notes']
  
  for (const field of fieldsToCompare) {
    if (originalSlot[field] !== newSlot[field]) {
      return true
    }
  }
  
  return false
}

// Fonction utilitaire pour traiter les TimeSlots en √©vitant les entr√©es modifiedBy inutiles
export function processTimeSlots(newTimeSlots: any[], originalTimeSlots: any[], userId: string): any[] {
  return newTimeSlots.map((slot: any) => {
    // Trouver le slot original correspondant (par ID)
    const originalSlot = originalTimeSlots.find((orig: any) => orig.id === slot.id)
    
    // Si c'est un nouveau slot (pas dans les originaux), ne pas ajouter d'entr√©e "modified"
    if (!originalSlot) {
      return {
        ...slot,
        id: slot.id || generateTimeSlotId()
        // Pas d'entr√©e modifiedBy pour les nouveaux slots - ils auront "created" par ailleurs
      }
    }
    
    // V√©rifier si le slot a r√©ellement chang√©
    const hasChanged = hasTimeSlotChanged(originalSlot, slot)
    
    if (hasChanged) {
      // Seulement si modifi√©, ajouter l'entr√©e modifiedBy
      return {
        ...slot,
        id: slot.id || generateTimeSlotId(),
        modifiedBy: [
          ...(slot.modifiedBy || []),
          {
            userId,
            date: new Date().toISOString(),
            action: 'modified' as const
          }
        ]
      }
    } else {
      // Si pas modifi√©, retourner le slot tel quel (sans ajouter d'entr√©e modifiedBy)
      return {
        ...slot,
        id: slot.id || generateTimeSlotId()
      }
    }
  })
}

// ================================
// FONCTIONS UTILITAIRES POUR LES SALLES
// ================================

interface Room {
  id: string
  name: string
  description?: string
  is_active: boolean
  capacity: number
  locations?: RoomLocation[]
}

interface RoomLocation {
  id: string
  room_id: string
  name: string
  description?: string
  is_active: boolean
}

// Fonction pour obtenir toutes les salles
export async function getAllRooms(): Promise<Room[]> {
  try {
    const [rows] = await pool.execute(`
      SELECT 
        r.id,
        r.name,
        r.description,
        r.is_active,
        r.capacity
      FROM rooms r
      WHERE r.is_active = TRUE
      ORDER BY r.name ASC
    `)
    
    const rooms = rows as any[]
    
    // Pour chaque salle, r√©cup√©rer ses localisations
    const roomsWithLocations = await Promise.all(
      rooms.map(async (room) => {
        const [locationRows] = await pool.execute(`
          SELECT 
            id,
            room_id,
            name,
            description,
            is_active
          FROM room_locations
          WHERE room_id = ? AND is_active = TRUE
        `, [room.id])
        
        return {
          id: String(room.id),
          name: room.name,
          description: room.description,
          is_active: room.is_active,
          capacity: room.capacity,
          locations: (locationRows as any[]).map(loc => ({
            id: String(loc.id),
            room_id: String(loc.room_id),
            name: loc.name,
            description: loc.description,
            is_active: loc.is_active
          }))
        }
      })
    )
    
    return roomsWithLocations
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des salles:', error)
    throw error
  }
}

// Fonction pour obtenir les salles par localisation
export async function getRoomsByLocation(locationId: number): Promise<Room[]> {
  try {
    const [rows] = await pool.execute(`
      SELECT 
        r.*,
        l.name as location_name,
        l.description as location_description
      FROM rooms r
      INNER JOIN room_locations l ON r.id = l.room_id
      WHERE l.id = ? AND r.is_active = TRUE AND l.is_active = TRUE
      ORDER BY r.name ASC
    `, [locationId])
    
    return (rows as any[]).map(row => ({
      id: String(row.id),
      name: row.name,
      description: row.description,
      is_active: row.is_active,
      capacity: row.capacity,
      locations: [{
        id: String(locationId),
        room_id: String(row.id),
        name: row.location_name,
        description: row.location_description,
        is_active: true
      }]
    }))
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des salles par localisation:', error)
    throw error
  }
}

// Fonction pour obtenir les √©v√©nements associ√©s √† une salle
export async function getEventsForRoom(roomName: string, startDate?: string, endDate?: string): Promise<CalendarEventWithTimeSlots[]> {
  try {
    // R√©cup√©rer les √©v√©nements de chimie et physique pour cette salle
    const [chemistryEvents, physicsEvents] = await Promise.all([
      getChemistryEventsWithTimeSlots(startDate, endDate),
      getPhysicsEventsWithTimeSlots(startDate, endDate)
    ])
    
    // Filtrer par salle et fusionner les r√©sultats
    const filteredChemistry = chemistryEvents.filter(event => {
      const roomData = normalizeRoomData(event.room)
      return roomData && (roomData.name === roomName || roomData.id === roomName)
    })
    
    const filteredPhysics = physicsEvents.filter(event => {
      const roomData = normalizeRoomData(event.room)
      return roomData && (roomData.name === roomName || roomData.id === roomName)
    })
    
    return [...filteredChemistry, ...filteredPhysics].sort((a, b) => 
      new Date(a.start_date).getTime() - new Date(b.start_date).getTime()
    )
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des √©v√©nements pour la salle:', error)
    throw error
  }
}

export type { Room, RoomLocation };

// =====================================================================================
// FONCTIONS ADDITIONNELLES POUR LA GESTION COMPLETE DES TIMESLOTS
// =====================================================================================

/**
 * Fonction pour supprimer/marquer un timeSlot comme supprim√©
 * Diff√©rence entre chimie (marquer comme deleted) et physique (supprimer compl√®tement)
 */
export function removeTimeSlot(
  timeSlots: any[],
  index: number,
  userId: string,
  mode: 'chemistry' | 'physics' = 'chemistry'
): any[] {
  const activeSlots = timeSlots.filter(slot => slot.status !== 'deleted');
  
  // Ne pas supprimer s'il n'y a qu'un seul slot actif
  if (activeSlots.length <= 1) {
    console.warn('üîç [removeTimeSlot] Impossible de supprimer le dernier slot actif');
    return timeSlots;
  }

  const newTimeSlots = [...timeSlots];
  const slotToRemove = newTimeSlots[index];
  
  if (mode === 'chemistry') {
    // Mode chimie : marquer comme supprim√© si existant, supprimer si nouveau
    if (slotToRemove.isExisting) {
      slotToRemove.status = 'deleted';
      slotToRemove.wasModified = true;
      
      // Ajouter l'entr√©e de modification
      if (!slotToRemove.modifiedBy) {
        slotToRemove.modifiedBy = [];
      }
      slotToRemove.modifiedBy.push({
        userId,
        date: new Date().toISOString(),
        action: 'deleted',
        note: 'Supprim√© via EditEventDialog'
      });
      
      console.log('üîç [removeTimeSlot] Slot existant marqu√© comme supprim√©:', {
        slotId: slotToRemove.id,
        userId,
        mode
      });
      
      return newTimeSlots;
    } else {
      // Nouveau slot cr√©√© dans cette session, supprimer compl√®tement
      const filteredSlots = timeSlots.filter((_, i) => i !== index);
      console.log('üîç [removeTimeSlot] Nouveau slot supprim√© compl√®tement:', {
        slotIndex: index,
        userId,
        mode
      });
      return filteredSlots;
    }
  } else {
    // Mode physique : supprimer compl√®tement
    const filteredSlots = timeSlots.filter((_, i) => i !== index);
    console.log('üîç [removeTimeSlot] Slot supprim√© en mode physique:', {
      slotIndex: index,
      userId,
      mode
    });
    return filteredSlots;
  }
}

/**
 * Fonction pour initialiser les timeSlots locaux depuis un √©v√©nement existant
 * G√®re la conversion entre l'ancien syst√®me et le nouveau syst√®me TimeSlots
 * Version sp√©cialis√©e pour les composants EditEventDialog
 */
export function initializeLocalTimeSlotsFromEvent(event: any): any[] {
  if (!event) return [];

  console.log('üîç [initializeTimeSlotsFromEvent] Initialisation depuis √©v√©nement:', {
    eventId: event.id,
    hasTimeSlots: !!event.timeSlots,
    hasActuelTimeSlots: !!event.actuelTimeSlots,
    legacyDates: { start: event.start_date, end: event.end_date }
  });

  // Obtenir les cr√©neaux actifs
  const activeSlots = getActiveTimeSlots(event);
  
  if (activeSlots.length === 0) {
    console.warn('üîç [initializeTimeSlotsFromEvent] Aucun cr√©neau actif trouv√©');
    return [];
  }

  // Convertir les cr√©neaux actifs en format local avec tra√ßabilit√©
  const formattedTimeSlots = activeSlots.map(slot => ({
    id: slot.id,
    date: new Date(slot.startDate),
    startTime: format(new Date(slot.startDate), 'HH:mm'),
    endTime: format(new Date(slot.endDate), 'HH:mm'),
    status: (slot.status || 'active') as 'active' | 'deleted' | 'cancelled',
    isExisting: true,
    wasModified: false,
    originalData: {
      date: new Date(slot.startDate),
      startTime: format(new Date(slot.startDate), 'HH:mm'),
      endTime: format(new Date(slot.endDate), 'HH:mm')
    },
    createdBy: slot.createdBy,
    modifiedBy: slot.modifiedBy || [] // Conservation compl√®te de l'historique
  }));

  console.log('üîç [initializeTimeSlotsFromEvent] TimeSlots initialis√©s:', {
    count: formattedTimeSlots.length,
    slots: formattedTimeSlots.map(s => ({
      id: s.id,
      date: s.date?.toISOString(),
      time: `${s.startTime}-${s.endTime}`,
      isExisting: s.isExisting
    }))
  });

  return formattedTimeSlots;
}

/**
 * Fonction pour valider les donn√©es before submission
 */
export function validateEventSubmission(formData: any, timeSlots: any[], showMultipleSlots: boolean): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Validation du titre
  if (!formData.title || !formData.title.trim()) {
    errors.push('Le titre est requis');
  }

  // Validation des cr√©neaux
  if (showMultipleSlots) {
    const activeSlots = timeSlots.filter(slot => slot.status !== 'deleted');
    if (activeSlots.length === 0) {
      errors.push('Au moins un cr√©neau horaire est requis');
    }

    // V√©rifier chaque cr√©neau
    activeSlots.forEach((slot, index) => {
      if (!slot.date || !slot.startTime || !slot.endTime) {
        errors.push(`Cr√©neau ${index + 1} : date, heure de d√©but et heure de fin sont requises`);
      }
    });
  } else {
    // Mode cr√©neau unique
    if (!formData.startDate || !formData.startTime || !formData.endTime) {
      errors.push('Date, heure de d√©but et heure de fin sont requises');
    }
  }

  // Avertissements pour heures hors ouverture
  const checkBusinessHours = (startTime: string, endTime: string, label: string = '') => {
    if (startTime) {
      const [startHour] = startTime.split(':').map(Number);
      if (startHour < 8) {
        warnings.push(`${label}d√©but avant 8h00`);
      }
    }
    
    if (endTime) {
      const [endHour, endMinute] = endTime.split(':').map(Number);
      if (endHour > 19 || (endHour === 19 && endMinute > 0)) {
        warnings.push(`${label}fin apr√®s 19h00`);
      }
    }
  };

  if (showMultipleSlots) {
    timeSlots.filter(slot => slot.status !== 'deleted').forEach((slot, index) => {
      checkBusinessHours(slot.startTime, slot.endTime, `Cr√©neau ${index + 1} : `);
    });
  } else {
    checkBusinessHours(formData.startTime, formData.endTime);
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Fonction pour d√©tecter si seuls les timeSlots ont chang√©
 * Utilis√©e pour d√©terminer s'il faut utiliser l'API de d√©placement
 */
export function detectOnlyTimeSlotsChanged(
  formData: any,
  originalEvent: any,
  compareRoomDataFn?: (room1: any, room2: any) => boolean
): boolean {
  if (!originalEvent) return false;

  const roomComparison = compareRoomDataFn ? 
    compareRoomDataFn(formData.room, originalEvent.room) :
    compareRoomData(formData.room, originalEvent.room);

  return (
    formData.title === originalEvent.title &&
    formData.description === originalEvent.description &&
    formData.type === originalEvent.type &&
    roomComparison &&
    formData.location === originalEvent.location &&
    // Pour la physique, comparer consommables au lieu de chemicals
    JSON.stringify(formData.consommables || formData.chemicals || []) === 
      JSON.stringify(originalEvent.consommables || originalEvent.chemicals || []) &&
    JSON.stringify(formData.materials || []) === JSON.stringify(originalEvent.materials || [])
  );
}

/**
 * Fonction pour pr√©parer les donn√©es de d√©placement pour l'API move
 */
export function prepareMoveApiData(timeSlots: any[]): any[] {
  return timeSlots
    .filter(slot => slot.date && slot.startTime && slot.endTime && slot.status !== 'deleted')
    .map(slot => ({
      date: slot.date.toISOString().split('T')[0],
      startTime: slot.startTime,
      endTime: slot.endTime
    }));
}

/**
 * Fonction centralis√©e pour la cr√©ation de TimeSlots - VERSION SERVEUR
 * Centralise toute la logique de cr√©ation des timeSlots pour les APIs (POST uniquement)
 */
export function processTimeSlotCreation(
  timeSlots: any[],
  userId: string
): {
  generatedTimeSlots: TimeSlot[];
  actuelTimeSlots: TimeSlot[];
  validation: {
    isValid: boolean;
    errors: string[];
    warnings: string[];
  };
} {
  const errors: string[] = []
  const warnings: string[] = []
  
  // Validation des timeSlots d'entr√©e
  if (!timeSlots || timeSlots.length === 0) {
    errors.push('Au moins un cr√©neau horaire est requis')
    return {
      generatedTimeSlots: [],
      actuelTimeSlots: [],
      validation: { isValid: false, errors, warnings }
    }
  }

  // Filtrer et valider les cr√©neaux
  const validSlots = timeSlots.filter((slot: any) => {
    if (!slot.startTime || !slot.endTime) {
      warnings.push(`Cr√©neau ignor√©: heures manquantes (startTime="${slot.startTime}", endTime="${slot.endTime}")`)
      return false
    }
    return true
  })

  if (validSlots.length === 0) {
    errors.push('Aucun cr√©neau valide trouv√©')
    return {
      generatedTimeSlots: [],
      actuelTimeSlots: [],
      validation: { isValid: false, errors, warnings }
    }
  }

  const currentDate = new Date().toISOString()
  
  // G√©n√©rer les TimeSlots avec historique int√©gr√© dans modifiedBy
  const generatedTimeSlots: TimeSlot[] = validSlots.map((slot: any, index: number) => {
    // Utiliser slot.date si pr√©sent, sinon date par d√©faut (aujourd'hui)
    const slotDate = slot.date || new Date().toISOString().split('T')[0]
    
    // Valider et nettoyer les heures
    const startTime = slot.startTime?.trim()
    const endTime = slot.endTime?.trim()
    
    if (!startTime || !endTime) {
      throw new Error(`Heures manquantes pour le cr√©neau ${index + 1}: startTime="${startTime}", endTime="${endTime}"`)
    }
    
    // Construire les dates ISO compl√®tes
    const startDate = `${slotDate}T${startTime}:00`
    const endDate = `${slotDate}T${endTime}:00`
    
    return {
      id: generateTimeSlotId(),
      startDate,
      endDate,
      status: 'active' as const,
      createdBy: userId,
      modifiedBy: [{
        userId,
        date: currentDate, // Format requis par TimeSlot
        action: 'created' as const,
        note: `Cr√©ation automatique - nouvelles dates: ${startDate} -> ${endDate}`
      }],
      // Champs optionnels du TimeSlot
      actuelTimeSlotsReferent: slot.actuelTimeSlotsReferent,
      referentActuelTimeID: slot.referentActuelTimeID
    } as TimeSlot
  })

  // √Ä la cr√©ation, actuelTimeSlots = timeSlots
  const actuelTimeSlots = [...generatedTimeSlots]

  console.log('üîç [processTimeSlotCreation] TimeSlots g√©n√©r√©s:', {
    inputSlotsCount: timeSlots.length,
    validSlotsCount: validSlots.length,
    generatedCount: generatedTimeSlots.length,
    actuelCount: actuelTimeSlots.length,
    generatedTimeSlots,
    actuelTimeSlots
  })

  return {
    generatedTimeSlots,
    actuelTimeSlots,
    validation: {
      isValid: errors.length === 0,
      errors,
      warnings
    }
  }
}

/**
 * Fonction centralis√©e pour la mise √† jour de TimeSlots - VERSION SERVEUR
 * G√®re la mise √† jour correcte d'actuelTimeSlots selon les permissions utilisateur
 */
export function processTimeSlotUpdate(
  newTimeSlots: any[],
  existingEvent: any,
  userId: string
): {
  updatedTimeSlots: TimeSlot[];
  updatedActuelTimeSlots: TimeSlot[];
  validation: {
    isValid: boolean;
    errors: string[];
    warnings: string[];
  };
} {
  const errors: string[] = []
  const warnings: string[] = []
  
  // Validation des timeSlots d'entr√©e
  if (!newTimeSlots || newTimeSlots.length === 0) {
    errors.push('Au moins un cr√©neau horaire est requis')
    return {
      updatedTimeSlots: [],
      updatedActuelTimeSlots: [],
      validation: { isValid: false, errors, warnings }
    }
  }

  const currentDate = new Date().toISOString()
  const isOwner = existingEvent.created_by === userId

  console.log('üîç [processTimeSlotUpdate] Analyse des TimeSlots re√ßus:', {
    timeSlotsCount: newTimeSlots.length,
    firstSlot: newTimeSlots[0],
    hasStartDate: !!newTimeSlots[0]?.startDate,
    hasStartTime: !!newTimeSlots[0]?.startTime,
    isOwner
  })

  if (isOwner) {
    // Le propri√©taire peut remplacer compl√®tement les timeSlots
    console.log('üîç [processTimeSlotUpdate] Mise √† jour par le propri√©taire')
    
    // V√©rifier si les TimeSlots sont d√©j√† au bon format (avec startDate/endDate ISO)
    const areTimeSlotsPrepared = newTimeSlots.every(slot => 
      slot.startDate && slot.endDate && !slot.startTime && !slot.endTime
    )

    if (areTimeSlotsPrepared) {
      // TimeSlots d√©j√† pr√©par√©s, les utiliser directement
      console.log('üîç [processTimeSlotUpdate] TimeSlots d√©j√† au format ISO, utilisation directe')
      
      // Valider les TimeSlots pr√©par√©s
      const validSlots = newTimeSlots.filter((slot: any) => {
        if (!slot.startDate || !slot.endDate) {
          warnings.push(`Cr√©neau ignor√©: dates manquantes`)
          return false
        }
        return true
      })

      if (validSlots.length === 0) {
        errors.push('Aucun cr√©neau valide trouv√©')
        return {
          updatedTimeSlots: [],
          updatedActuelTimeSlots: [],
          validation: { isValid: false, errors, warnings }
        }
      }

      // Assurer que tous les slots ont les propri√©t√©s requises
      const processedTimeSlots = validSlots.map((slot: any) => ({
        ...slot,
        id: slot.id || generateTimeSlotId(),
        status: slot.status || 'active',
        createdBy: slot.createdBy || userId,
        modifiedBy: slot.modifiedBy || [{
          userId,
          date: currentDate,
          action: 'updated' as const
        }]
      }))

      return {
        updatedTimeSlots: processedTimeSlots,
        updatedActuelTimeSlots: processedTimeSlots.filter((slot: any) => slot.status === 'active'),
        validation: {
          isValid: true,
          errors,
          warnings
        }
      }
    } else {
      // TimeSlots au format startTime/endTime, utiliser processTimeSlotCreation
      const timeSlotResult = processTimeSlotCreation(newTimeSlots, userId)
      
      if (!timeSlotResult.validation.isValid) {
        return {
          updatedTimeSlots: [],
          updatedActuelTimeSlots: [],
          validation: timeSlotResult.validation
        }
      }

      return {
        updatedTimeSlots: timeSlotResult.generatedTimeSlots,
        updatedActuelTimeSlots: timeSlotResult.actuelTimeSlots, // Owner remplace actuelTimeSlots
        validation: timeSlotResult.validation
      }
    }
  } else {
    // Autre utilisateur : utiliser processTimeSlots pour proposer des modifications
    console.log('üîç [processTimeSlotUpdate] Mise √† jour par un autre utilisateur')
    
    // Traiter les TimeSlots selon leur format
    let timeSlotResult
    const areTimeSlotsPrepared = newTimeSlots.every(slot => 
      slot.startDate && slot.endDate && !slot.startTime && !slot.endTime
    )

    if (areTimeSlotsPrepared) {
      // TimeSlots d√©j√† au format ISO, cr√©er un r√©sultat compatible
      timeSlotResult = {
        generatedTimeSlots: newTimeSlots,
        validation: { isValid: true, errors: [], warnings: [] }
      }
    } else {
      // TimeSlots au format startTime/endTime
      timeSlotResult = processTimeSlotCreation(newTimeSlots, userId)
    }
    
    if (!timeSlotResult.validation.isValid) {
      return {
        updatedTimeSlots: [],
        updatedActuelTimeSlots: existingEvent.actuelTimeSlots || [],
        validation: timeSlotResult.validation
      }
    }

    // Utiliser processTimeSlots pour merger avec l'historique
    const processedTimeSlots = processTimeSlots(
      timeSlotResult.generatedTimeSlots, 
      existingEvent.timeSlots || [], 
      userId
    )

    return {
      updatedTimeSlots: processedTimeSlots,
      updatedActuelTimeSlots: existingEvent.actuelTimeSlots || [], // Ne pas toucher actuelTimeSlots
      validation: timeSlotResult.validation
    }
  }
}
